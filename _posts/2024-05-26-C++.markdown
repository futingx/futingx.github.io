---
layout: post
title:  "C++常用容器"
categories: C++  # 文章类别
tags:  C++ #文章标签
author: FTX #作者
---

* content
{:toc}

##### &emsp;这里我们介绍一下 **C++** 算法竞赛中的STL常用的容器和函数用法：
在这个C++ STL容器运用的部分，我们只简单的介绍常用的语法和运用，每一个容器的结束也都会举与容器有关的题目来实践运用。如有补充不全或者错误，还请多包涵。

### &emsp;一.vector容器

##### &emsp;1.1 介绍：
- 引入头文件：`#include<vector>`
- 动态数组,可以随时删除和增加元素，相比于直接在局部定义数组大小，vector不会发生爆栈，对大容量存储数据很友好。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- | 函数     | 作用    |
| --------   | ------   |
| `a.push_back(x)`     | 将元素添加到向量的末尾|
| `a.pop_back(x)`|  从向量的末尾删除元素|
| `a.front(x)`     |    返回向量的第一个元素的引用|
| `a.back(x)`     |    返回向量的最后一个元素的引用|
| `a.size()`     |    返回向量中元素的数量|
| `a.resize()`     |    更改向量的大小|
| `a.insert()`     |    在指定位置插入元素|
| `a.erase(first,last)`     |    删除指定范围内的元素    |
| `a.clear()`     |    删除向量中的所有元素|
| `a.empty()`     |    检查向量是否为空|

```c++
#include <bits/stdc++.h> //我个人喜欢用(基本上包含了所有容器)
using namespace std;

int main() {
    std::vector<int> vec;

    // 将元素添加到向量的末尾
    vec.push_back(5); // 现在vec中有一个元素 5

    // 从向量的末尾删除元素
    vec.pop_back(); // 现在vec为空

    // 返回向量的第一个元素的引用
    vec.push_back(3);
    std::cout << vec.front() << std::endl; // 输出 3

    // 返回向量的最后一个元素的引用
    std::cout << vec.back() << std::endl; // 输出 3

    // 返回向量中元素的数量
    std::cout << vec.size() << std::endl; // 输出 1

    // 更改向量的大小
    vec.resize(3); // 现在vec中有3个元素，值为0

    // 在指定位置插入元素
    vec.insert(vec.begin() + 1, 10); // 在第二个位置插入元素10

    // 删除指定范围内的元素
    vec.erase(vec.begin(), vec.begin() + 2); // 删除前两个元素

    // 删除向量中的所有元素
    vec.clear(); // 现在vec为空

    // 检查向量是否为空
    if (vec.empty()) 
    {
        std::cout << "Vector is empty" << std::endl;
    }

    return 0;
}
```

##### &emsp;1.3 实践运用：

- 题目来源：[(1211 - 数组元素的插入-东方博宜OJ (czos.cn)](https://oj.czos.cn/p/1211)
```c++
#include<bits/stdc++.h> // 包含标准库头文件
using namespace std; // 使用标准命名空间

int main(){
    int n; // 定义变量n，表示数组大小
    cin>>n; // 输入数组大小
    vector<int> a; // 声明一个整型向量a，用于存储输入的元素
    for(int i=0;i<n;i++) // 循环n次，读入n个元素
    {
        int k; // 定义变量k，表示当前输入的元素值
        cin>>k; // 输入元素值
        a.push_back(k); // 将元素值k插入到向量a的末尾
    }
    int x,y; // 定义变量x和y，表示要插入的位置和元素值
    cin>>x>>y; // 输入要插入的位置和元素值
    
    a.insert(a.begin()+x-1,y); // 在位置x-1处插入元素值y
    
    //c++11循环语法 
    for(auto &it:a) // 遍历向量a中的所有元素
    {
        cout<<it<<" "; // 输出当前元素值，并跟一个空格
    }
    return 0; 
}
```

<hr/>

### &emsp;二.pair容器

##### &emsp;1.1 介绍：

- pair 是一个简单的将两个数据组合成一个单元的数据结构。它常用于需要同时存储两个相关数据的情况，例如键值对或坐标等。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

-
<hr/>





### &emsp;三.queue容器

##### &emsp;1.1 介绍：

- queue 是一个先进先出（FIFO）的数据结构，它模拟了排队的行为。元素从队列的一端进入（称为后端），并从另一端离开（称为前端）。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;四.deque容器

##### &emsp;1.1 介绍：

- deque 是双端队列（Double-Ended Queue）的缩写，它是一种可以在两端进行高效插入和删除操作的动态数组。与普通的队列不同，deque 允许在头部和尾部都进行快速的插入和删除。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;五.priority_queue容器

##### &emsp;1.1 介绍：

- priority_queue 是一个优先队列，它会按照元素的优先级自动对元素进行排序。元素的优先级可以通过自定义的比较函数或元素自身的特性来确定。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;六.set容器

##### &emsp;1.1 介绍：

- set 是一种集合数据结构，它存储一组唯一的元素。set 中的元素是无序的，并且不允许重复。它提供了高效的元素插入、删除和查找操作。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;七.map容器

##### &emsp;1.1 介绍：

- map 是一种关联容器，它将键（Key）与值（Value）关联起来。map 中的元素是按照键进行排序的，并且键必须是唯一的。它提供了高效的键值对存储和查找功能。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;八.string容器

##### &emsp;1.1 介绍：

- string 是表示字符串的容器，它提供了对字符串的各种操作，如拼接、截取、查找等。string 实现了高效的字符串处理功能，并且可以自动管理字符串的内存。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;九.stack容器

##### &emsp;1.1 介绍：

- stack 是一种后进先出（LIFO）的数据结构，它模拟了栈的行为。元素只能从栈顶进行插入和删除操作，最后进入栈的元素最先被取出。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 

##### &emsp;1.3 实践运用：

- 

<hr/>

### &emsp;十.tuple容器

##### &emsp;1.1 介绍：

- tuple 是一种固定大小的元组数据结构，可以存储多个不同类型的元素。它提供了一种方便的方式来组合多个相关的数据项，并可以通过索引或类型推导来访问这些元素。

##### &emsp;1.2 容器包含的函数(介绍常用的一些，其余的可以去百度)：

- 引入头文件：`#include<vector>`
- 不过我个人更喜欢万能头文件`#include<bits/stdc++.h>`,万能头文件有可能会降低程序运行效率，有利有弊但是不需要记这么多容器word

##### &emsp;1.3 实践运用：

- 

<hr/>
