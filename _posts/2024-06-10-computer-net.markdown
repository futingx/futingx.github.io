---
layout: post
title:  "计算机网络"
categories: 计算机网络  # 文章类别
tags:  计算机网络 #文章标签
author: FTX #作者
---

* content
{:toc}

# 计算机网络（第八版）学习笔记

##  简介
《计算机网络》（第八版）由谢希仁编著，是一本系统介绍计算机网络基础理论与实践的经典教材。

##  内容概述
### [1. 网络层](#jumpone)
### [2. 传输层](#jumptwo)
### [3. 网络安全](#jumpthree)





## <span id="jumpone">1.网络层</span>
### 1.1 IP地址与子网划分
#### IP地址

#### 作用

- 用于决定数据包最终到达哪个计算机

#### 组成

* 由32位比特组成，即4个字节
* 这32位可以分为两个部分，称为网络号和主机号
* 同一网段的计算机网络号相同，路由器负责连接不同的网段，而交换机负责连接同一网段中不同的计算机
* 同一网段的计算机主机号不同
* 计算机在和其他计算机进行通信之前需要判断目标IP和自己的IP网络是否相同
  * 相同，则目标MAC地址写目标计算机的MAC地址
  * 不同，则目标MAC地址写本网段的路由器的MAC地址

#### 表示方法

* 二进制表示法

  11111111.10110011.11101000.10010010

* 点分十进制法

  192.168.1.122

#### 分类

* A，B，C：用于日常使用
* D：用于组(多)播
* E：保留，目前还没用

![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E5%92%AF%E5%B1%82/01.%20IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/images/%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg)



### 子网掩码

#### 作用

* 用于计算IP地址的网络号和主机号

#### 组成

* 表示网络号的位置全1，表示主机号的位置全0
* 比如C类地址：192.168.1.125，其子网掩码为 255.255.0.0

#### 原理

* 子网掩码与计算地址进行与计算，全1才1，有0则0
* 则计算结果网络号原样输出，主机号全为0

#### 分类

* A类：255.0.0.0
* B类：255.255.0.0
* C类：255.255.255.0
* D类：没有子网掩码
* E类：没有子网掩码



### 特殊地址

* 网段地址：主机号全0
* 广播地址：主机号全1
* 回环地址：127.0.0.1，只要装了TCP/IP就行，不需要经过网卡
* 回送地址：127.x.x.x
* 冲突地址：0.0.0.0，如果本机的IP和本网段中其他计算机相同(冲突)，则为0.0.0.0，子网掩码为0.0.0.0



### 公网内网

#### 公网

* 由美国机构 Inter NIC 负责，各国各级 ISP 使用的公网需要向Inter NIC申请

#### 内网

* 局域网

* A类：10.0.0.0/255.0.0.0
* B类：172.16.0.0/255.255.0.0 - 172.31.0.0/255.255.0.0
* C类：192.168.0.0/255.255.255.0 - 192.168.255.0/255.255.255.0

#### NAT/PAT

* 内网地址访问 Internet 需要 NAT/PAT 技术

* NAT：网络地址转换
  * 所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接
* PAT：端口地址转换
  * 在使用NAT时，如果只有一个公有IP，而有多个内部IP，这个时候NAT就要通过映射不同的端口来跟踪记录不同的会话
  * 则NAT会将用户A、B、C访问分别映射到1088、1098、23100【举例】，此时实际上就是PAT了



### 子网划分

#### 概念

* 子网划分就是利用现有网段的主机号的头几位作为网络号，这些位置称为子网号，子网号的概念只存在于分类编址

#### 作用

* 减少地址浪费

#### 注意

* 子网只能等分
* 主机号全为0不能用，因为这表示网段
* 主机号全为1不能用，因为这是广播地址
* 因此能用的主机号范围是 [差点全0，差点全1]

#### 例子

![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E5%92%AF%E5%B1%82/01.%20IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/images/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.jpeg)



### 无分类编制

#### 概念

* 不分类了，只分网络号和主机号
* 通过子网掩码确定网络号和主机号

#### CIDR记法

* 一个无分类编制的IP地址为   

  11100110110010101001010101110101

  | 含义         | 网络号 | 主机号                     |
  | ------------ | ------ | -------------------------- |
  | 无分类编制IP | 111001 | 10110010101001010101110101 |
  | 子网掩码     | 111111 | 00000000000000000000000000 |

* CIDR记法为

  230.202.149.117/6

  其中6表示子网掩码的前6位是1，其他为0

#### 例子



![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E5%92%AF%E5%B1%82/01.%20IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/images/%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%88%B6.jpeg)

### 1.2 静态路由与动态路由
### 网络畅通的条件

* 数据报包有去有回
* 网络中的路由器必须知道且只需要知道下一跳的地址【路由器只要知道下一跳地址就行，不必知道如何到达任意的路由器，因为如果要实现，路由表将非常非常巨大，这是不可能的】



### 静态路由

* 静态路由是指网络管理员手动构建路由器的路由表，告诉路由器下一跳的地址
* 对于路由器，直连的网段不用加路由信息，自动识别



### 静态路由汇总

* 静态路由汇总需求分析

* * 如果A网段和B网段都有很多的计算机，那么A网段为了与B网段联通，则需要在A网关填写B网段中所有的IP地址，则需要在B网关填写A网段中所有的IP地址，这是不实际的
  * 比如北京市的所有计算机想要和石家庄的计算机网络连通，则北京市总路由要写石家庄网段所有的IP地址，石家庄总路由要写北京市网段所有的IP地址，这是不实际的
  * 为了简化路由表，需要将多条路由合并为一条，为此引出静态路由汇总

* 路由汇总实现

  * A网关将所有去往B网段的静态路由配置为B的网关地址，B网关将所有去往A网段的静态路由配置为A的网关地址，从而实现路由汇总

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/02.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/images/%E5%9B%BE1.PNG)

* 匹配顺序：优先匹配子网掩码大的网段，因为掩码大的网段范围小

```
172.16.1.0 / 255.255.255.0     10.0.0.2  优先度：A
172.16.0.0 / 255.255.0.0       10.0.0.2  优先度：B
172.0.0.0  / 255.0.0.0         10.0.0.2  优先度：C
0.0.0.0    / 0.0.0.0           10.0.0.2  优先度：D
```

* 默认路由

  * 最大网段：0.0.0.0 / 0.0.0.0，这个网段代表互联网

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/02.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/images/%E5%9B%BE2.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/02.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/images/%E5%9B%BE3.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/02.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/images/%E5%9B%BE4.PNG)



### 动态路由

* 动态路由是指路由器能够自动地构建自己的路由表，并且能根据实际情况动态发生改变



### 动态路由协议 - RIP

* RIP协议特点

  * RIP每30秒发送一次自己的路由表，从而进行路由表更新
  * 选择到达目标网络所经过路由器最少的路径为最佳路径，即最小跳数
  * 默认允许的最大跳数为15跳，即认为16跳或以上的路由器是不可达的
  * RIP适合小型网络，不适合大型网络

* RIP工作原理

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/02.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/images/%E5%9B%BE5.PNG)



### 动态路由协议 - OSPF

* 开放最短路径协议


### 1.3 IP协议簇

## IP协议

### IP协议全称

* Internet Protocol
* 互联网互连协议

### IP协议作用

* 实现数据在网络节点上互相传输

### IP协议特点

* 不面向连接
* 不保证可靠

### IP协议数据报结构

![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/03.%20IP%E5%8D%8F%E8%AE%AE%E7%B0%87/images/IP%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E6%8A%A5.PNG)

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 版本     | 目前有IPv4和IPv6两种版本                                     |
| 首部长度 | 单位4字节，所以首部长度最大为 15 * 4 = 60字节                |
| 区分服务 | 不同服务的优先级不同，从而保证服务质量保证(QoS)              |
| 总长度   | IP首部与数据部分字节之和，最大为 2^16-1个字节                |
| 片偏移   | 占13位，本分片再原始数据报文中相对首位的偏移位               |
| 生存时间 | TTL，指数据包跳转次数剩余，最多255跳                         |
| 协议     | 指明上层使用的协议，从而确定要给哪个进程                     |
| 标识     | IP协议软件中的一个数，用于唯一标识主机发送的数据报<br />在发出IP报文时，每个分片会被分配一个数<br />每分配一个报文，这个数加1，溢出则从0开始算<br />标识用于分片达到目的主机后进行重组 |
| 标志     | 最低位(MF)：MF=1表示后面还有分片，MF=0表示已经是最后一个分片<br />中间位(DF)：DF=1表示不允许分片，DF=0表示允许分片 |

* 片偏移计算

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/03.%20IP%E5%8D%8F%E8%AE%AE%E7%B0%87/images/%E7%89%87%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97.PNG)

* 片偏移示例

  ![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/03.%20IP%E5%8D%8F%E8%AE%AE%E7%B0%87/images/%E7%89%87%E5%81%8F%E7%A7%BB%E7%A4%BA%E4%BE%8B.PNG)



## ICMP协议

### ICMP协议全称

* Internet Control Message Protocol - 互联网控制报文协议

### ICMP协议作用

* 用于主机、路由器之间传递控制信息
* 控制信息指：网络是否流畅，路由器是否可用，主机是否可达

### ICMP协议使用

* ICMP数据报一般被TCP/UDP协议使用，也可以被用户进程使用
* 命令行使用：`trace IP地址`，即可看到IP数据包沿途所经过的路由器的信息

### ICMP协议数据报传输

* ICMP报文被封装再IP数据报内，随IP数据报进行传输

![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/03.%20IP%E5%8D%8F%E8%AE%AE%E7%B0%87/images/ICMP%E6%95%B0%E6%8D%AE%E6%8A%A5.PNG)

### ICMP报文类型和代码

![](https://github.com/gothicrush/learning/blob/master/Network/04.%20%E7%BD%91%E7%BB%9C%E5%B1%82/03.%20IP%E5%8D%8F%E8%AE%AE%E7%B0%87/images/ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.PNG)



## ARP协议

### ARP协议全称

* Address Resolution Protocol
* 地址解析协议

### ARP协议作用

* 用于将以太网（局域网）中的IP地址解析为MAC地址
* 因为当一个IP数据报来到一个局域网时，它不知道应该去哪个计算机，于是使用ARP协议发出一个广播，内容是`你们谁的IP地址是xxx.xxx.xxx.xxx的，告诉我你的MAC地址，我发数据给你`，目标计算机收到广播后，用ARP协议广播`我是啊，我的MAC地址是yyyy`
* 点到点链路使用PPP协议，不需要ARP协议

### ARP协议使用

* 命令行使用：`arp -a`，看到本机存储的`IP地址 <--> MAC地址`的映射表



## IGMP协议

### IGMP协议全称

* Internet Group Manage Protocol
* 互联网组管理协议

### IGMP协议作用

* 用于组播功能的实现
* 主机通过IGMP协议通知路由器希望接收或离开某个特定的组播组
* 路由器通过IGMP协议周期性查询组播组中成员状态，维护组播组中成员的关系

### 组播是什么

* 在发送者与每一个接收之间实现一对多的网络连接
* 如果发送者需要给多个接收者发送相同的数据，只需要发送一份数据就行
* 不用针对每个接收方都发送一份，提高了通信效率，减少资源使用

## <span id="jumptwo">2.传输层</span>

### 2.1 TCP协议

#### TCP协议特点

* 面向连接
  * 应用程序在使用TCP协议之前，必须先建立TCP连接
  * 在数据传输完毕后，必须释放已经建立的TCP连接
  * 类似于打电话
* 点对点通信
  * TCP协议就像打电话，只能一对一，不能一对多或多对多
* 可靠传输
  * TCP协议能够保证传输的数据无差错，不丢失，不重复，不乱序
* 全双工通信
  * TCP协议允许双方同时接收和发送数据
* 面向字节流
  * TCP协议传输的数据以字节为单位，以流的形式传输

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE1.PNG)



### TCP报文首部格式

* 结构图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE2.PNG)

* 序号示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE3.PNG)

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 序号     | 每个数据包的第一个字节位置在全数据中的位置                   |
| 源端口   | 发送方端口                                                   |
| 目的端口 | 接收方端口                                                   |
| 确认号   | 期待接收的下一个数据包的序号                                 |
| 数据偏移 | 指TCP报文数据部分开始位置，即TCP报文首部占用空间大小<br />数据偏移占4位，单位为"4字节"，即TCP报文首部最大为15*4=60字节<br />而TCP报文首部固定部分大小为20字节，即TCP首部可选部分最大为40字节 |
| 保留     | 保留，暂时没用                                               |
| 紧急URG  | 告诉发送发应优先发送                                         |
| 确认ACK  | ACK=1时有效，用于建立TCP连接                                 |
| 推送PUSH | 告诉接收方应优先接收                                         |
| 窗口     | 占2字节，范围[0，2^16-1]，用于TCP流量控制和拥塞控制          |
| 检验和   | 占2字节，计算检验和时，需要在TCP报文段前加上12字节的伪首部   |
| 紧急指针 | 仅在URG=1时有效，指明紧急数据的位置                          |
| 选项     | 长度可变，只有一种选项：**MSS**（Maximum Segment Size），最大报文段长度 |





### TCP可靠传输

#### 停止等待协议

* 概念

  * 发送方发送一个数据包，接收方接收后，返回一个确认包
  * 发送方只有当收到确认包后才发送下一个数据包
  * 现在已经不用这种技术，因为效率太低

* 丢包情况

  * 接收方没有受到数据包
    * 发送方超时重传
  * 接收方收到数据包，但发送方没有收到确认包
    * 发送方超时重传，接收方收到重复包后丢弃，返回确认包
  * 接收方收到数据包，但发送方超时收到确认包
    * 发送方超时重传，接收方收到重复包后丢弃，返回确认包

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE4.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE5.PNG)



#### 连续ARQ协议和滑动窗口协议

* 概念

  * 停止等待协议的改进版：一包一确认效率太低
  * 核心思想：多个包分为一组，收到一个组才进行一次确认
  * 一组的大小就是TCP窗口的大小
  * 现在主要使用这种技术

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE6.PNG)

* 流程图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE7.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE8.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE9.PNG)

* 选择性确认

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE10.PNG)

* 超时重传时间计算

  * 超时重传时间取决于TCP往返传输时间（**RTT**）
  * RTT计算方法1：TCP Timestamp
    * 在发送时放入发送时间点的时间戳，接收方收到时，用接收时间点时间戳减去发送时间点时间戳
  * RTT计算方法2：重传队列中数据包的TCP控制块
    * **不懂不懂**



### TCP流量控制

* 概念：流量控制是指TCP连接的两端（发送方，接收方）在进行数据传输时，控制其发送和接收数据包的个数

* 核心思想

  * TCP协议报文有窗口，发送方叫发送窗口，接收方叫接收窗口
  * TCP传输过程中，发送窗口和接收窗口都会动态改变其大小，从而改变一次发送数据包的个数和一次接收数据包的个数，最终实现流量控制

* 流程图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE11.PNG)

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE12.PNG)

### TCP拥塞控制

* 概念：TCP拥塞控制的参与者是整个网络所有节点，所有节点共同采取措施避免网络的拥塞

#### 慢开始算法

* 概念：发送方在发送数据包时，一次发送的数量(**MSS**)随发送次数逐渐增多（第n次发送2^n个）

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE13.PNG)



#### 拥塞控制方案一

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE14.PNG)



#### 快重传算法

* 概念：

  * 接收方每收到一个失序的分组后立即发送重复确认，这是为了使发送方能够及早知道分组没有及时到达而不要等到自己发送数据时才进行确认
  * 快重传规定：发送方只要一连收到三个重复确认就要立即重传没有准确送达的报文段，而不要等待超时重传时间

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE15.PNG)

#### 拥塞控制方案二

* 快重传配合快恢复算法

![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE16.PNG)

* 发送窗口 = min[接收窗口，拥塞窗口] 



### TCP连接管理

#### 连接建立 - 握手

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE17.PNG)

* 为什么需要3次握手

  * 背景：假设是2次握手
  * A申请与B握手，A --> B
  * 第一次：A发出建立连接请求r1，但是路由的路线很慢
  * 第二次：因为请求r1走的很慢，超时都不到达，所以A放弃第一次连接请求，发出第二次请求r2
  * B收到r2请求，并发出响应包q2，A收到响应包q2，至此，两次握手成功，连接建立
  * 过了一会，B收到r1，并发出响应包q1，A收到响应包q1，但是A之前已经放弃了第一次请求
  * 由于两次握手的原因，B认为已经建立了连接，而A不认为是建立了连接，所以B就一直维持连接状态

#### 连接释放 - 挥手

* 示意图

  ![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/%E5%9B%BE18.PNG)

* 为什么要等待2**MSL**（Maximum Segment Lifetime：最大报文生存时间）

  * 场景

    ```bash
    A主动向B请求断开
    
    1: A --> FIN --> B
    2: A <-- ACK <-- B
    # 此时A --> B连接已关闭
    3: A <-- FIN <-- B
    4: A --> ACK --> B
    ```

  * 等待2MSL的原因是为了确保 `A->ACK->B` 能够送达

  * 如果`A->ACK->B`丢失 -->  B认为`A<-FIN<-B`丢失，进行重传

  * A接收到`A<-FIN<-B`重传所需时间：`A<-FIN<-B`超时时间 + `A<-FIN<-B`传输时间

  * 为了保守与容易计算，保留两个**MSL**来确保A能接收到`A<-FIN<-B`重传包

  * 一旦A接收到`A<-FIN<-B`，就重新等待2MSL

  * 如果A在2MSL都没有收到`A<-FIN<-B`，则有两种情况

    * B已经收到了A的包：可以关闭
    * B端网络断开了：可以关闭



### SYN 攻击

* 攻击者频繁地与服务器建立连接，造成服务器带宽资源与计算机资源被耗尽



## UDP协议

### UDP协议特点

* 面向无连接：发送数据前不需要建立连接
* 不保证可靠传输：因为不建立连接
* 面向报文传输
* 支持一对一，一对多，多对多通信
* 首部开销小，只占8个字节，伪首部占12字节
* 不具有拥塞控制功能



### UDP报文结构

* 图中**16位UDP长度**和**UDP长度**相同

![](https://github.com/gothicrush/learning/blob/master/Network/05.%E4%BC%A0%E8%BE%93%E5%B1%82/images/udp.jpg)

### UDP校验和计算方法

* UDP包的伪首部和首部和数据报文全部按16位进行划分
* 然后将它们进行求和【此时参与计算的检验和为0】
* 然后结果取反码，得到真正的检验和
* 最后将其放入**检验和**中



### UDP检验和使用

* UDP包的伪首部和首部和数据报文全部按16位进行划分
* 然后将它们进行求和【此时参与计算的检验和为0】
* 如果结果为全1，则数据传输没错，否则数据传输出错



### DDos攻击

* 攻击者同时发送大量的UDP包给服务器


## <span id="jumpthree">3.网络安全</span>
### 网络安全的4种威胁

* 截获：从网络上窃听别人的通信内容；被动攻击
* 中断：有意中断他人在网络上的通讯；主动攻击
* 篡改：故意篡改网络上的报文；主动攻击
* 伪造：伪造信息在网络上传输；主动攻击
* 图例：



### 加密技术

#### 对称加密

* 概念
  * 对于要被加密的内容，其加密和解密都使用同一个密钥
  * 传输时，加密的内容和密钥都进行传输
* 优点
  * 加密和解密速度快
* 缺点
  * 因为加密算法公开，所以如果密钥被截获，就不安全了
* 常用对称加密算法
  * DES
  * AES

#### 非对称加密

* 概念
  * 非对称加密中有公钥和私钥两种密钥
  * 公钥加密的内容只有私钥可以解，私钥加密的内容只有公钥可以解
* 优点
  * 非常安全
* 缺点
  * 加密和解密速度慢
* 用途
  * 加密
    * A要加密东西发送给B
    * A先接收B的公钥，用公钥进行加密，然后传输加密后的数据给A
    * A用私钥解密
  * 签名
    * A用私钥进行加密
    * 其他人用A的公钥进行解密，如果能成功，则认为有A的签名
* 证书颁发机构
  * 如果一个假冒者，用自己的私钥加密，然后将自己的公钥和加密内容发送给你，你不能保证加密内容和公钥来源正确
  * 证书颁发机构能够保证加密内容和公钥的来源是正确的，不是伪造的

### SSL

#### 作用

* SSL服务器鉴别
* 加密SSL会话
* SSL客户端鉴别

#### 位置

* 位于应用层和传输层之间
* 在发送方，SSL接收应用层数据，对数据进行加密，然后将加密后的数据送往TCP
* 在接收方，SSL从TCP读取数据，解密后发送给应用层